#include "octane-oslintrin.h"

// Hybrid mandeltorus-mandelbub

//   OSL implementation from Mandelbulber 2.22 formula Mandeltorus
//   by Jesus Sosa with help of Carbuncle Grim (mclarekin) developer of mandelbulber
//

// Classic Mandelbulb fractal. Mandelbulber implementation
// http://www.fractalforums.com/3d-fractal-generation/true-3d-mandlebrot-type-fractal/

// Mandeltorus by Aexion
// Reference
// http://www.fractalforums.com/the-3d-mandelbulb/mandeldonuts/

struct vec3{ float x, y, z; };


vec3 __operator__add__(vec3 a, vec3 b) { return vec3(a.x+b.x, a.y+b.y, a.z+b.z); }
vec3 __operator__mul__(float val, vec3 v) { return vec3(val*v.x, val*v.y, val*v.z); }
vec3 __operator__div__(vec3 a, float b) { return vec3(a.x/b, a.y/b, a.z/b); }
vec3 __operator__mul__(float val, vec3 v) { return vec3(val*v.x, val*v.y, val*v.z);  }
vec3 __operator__mul__(vec3 a, vec3 b) 
{ 
  vector a1=vector(a.x,a.y,a.z);
  vector b1=vector(b.x,b.y,b.z);
  vector c1= a1*b1;
  return vec3(c1[0],c1[1],c1[2]);
//  return vec3(a.x * b.x, a.y * b.y, a.z * b.z); 
}
vec3 __operator__add__(vec3 a, float b) { return vec3(a.x+b, a.y+b, a.z+b); }
vec3 __operator__sub__(vec3 a, float b) { return vec3(a.x-b, a.y-b, a.z-b); }
vec3 __operator__sub__(vec3 a, vec3 b) { return vec3(a.x-b.x, a.y-b.y, a.z-b.z); }
vec3 __operator__mul__(vec3 a, float b) { return vec3(a.x*b, a.y*b, a.z*b); }

float length(vec3 v) { return length(vector(v.x,v.y,v.z)); }

vec3 fabs(vec3 a) { return vec3(fabs(a.x), fabs(a.y),fabs(a.z) ); }
float dot(vec3 a, vec3 b) { return a.x*b.x + a.y*b.y + a.z*b.z; }

vec3 swap_xy(vec3 a) { return vec3(a.y, a.x, a.z );}
vec3 swap_xz(vec3 a) { return vec3(a.z, a.y, a.x ); }
vec3 swap_yz(vec3 a) { return vec3(a.x, a.z, a.y ); }

// ------------------------------------------ mat3 ---------------------------------------------------
struct mat3{ float m00, m01, m02, m10, m11, m12, m20, m21, m22; };

mat3 __operator__mul__(float val, mat3 m) { return mat3(val*m.m00, m.m01, m.m02, m.m10, val*m.m11, m.m12, m.m20, m.m21, val * m.m22); }

mat3  rotationMatrix3(vec3 v, float angle)
{ float c = cos(radians(angle)), s = sin(radians(angle)); 
  return mat3(c+(1.0-c)*v.x*v.x, (1.0-c)*v.x*v.y-s*v.z, (1.0-c)*v.x*v.z+s*v.y, 
             (1.0-c)*v.x*v.y+s*v.z, c+(1.0-c)*v.y*v.y, (1.0-c)*v.y*v.z-s*v.x,
             (1.0-c)*v.x*v.z-s*v.y, (1.0-c)*v.y*v.z+s*v.x, c+(1.0-c)*v.z*v.z); 
}

mat3  rotationMatrix3(vector v, float angle)
{ float c = cos(radians(angle)), s = sin(radians(angle)); 
  return mat3(c+(1.0-c)*v[0]*v[0], (1.0-c)*v[0]*v[1]-s*v[2], (1.0-c)*v[0]*v[2]+s*v[1], 
             (1.0-c)*v[0]*v[1]+s*v[2], c+(1.0-c)*v[1]*v[1], (1.0-c)*v[1]*v[2]-s*v[0],
             (1.0-c)*v[0]*v[2]-s*v[1], (1.0-c)*v[1]*v[2]+s*v[0], c+(1.0-c)*v[2]*v[2]); 
}

mat3 __operator__mul__(mat3 A, mat3 B) 
{
  return mat3(A.m00*B.m00+A.m01*B.m10+A.m02*B.m20, A.m00*B.m01+A.m01*B.m11+A.m02*B.m21, A.m00*B.m02+A.m01*B.m12+A.m02*B.m22,
              A.m10*B.m00+A.m11*B.m10+A.m12*B.m20, A.m10*B.m01+A.m11*B.m11+A.m12*B.m21, A.m10*B.m02+A.m11*B.m12+A.m12*B.m22, 
              A.m20*B.m00+A.m21*B.m10+A.m22*B.m20, A.m20*B.m01+A.m21*B.m11+A.m22*B.m21, A.m20*B.m02+A.m21*B.m12+A.m22*B.m22); 
}
vec3 __operator__mul__(vec3 v, mat3 m) 
{
 return vec3(v.x*m.m00+v.y*m.m01+v.z*m.m02, v.x*m.m10+v.y*m.m11+v.z*m.m12, v.x*m.m20+v.y*m.m21+v.z*m.m22); 
}

vec3 __operator__mul__(vec3 v, mat3 m) 
{
 return vec3(v.x*m.m00+v.y*m.m01+v.z*m.m02, v.x*m.m10+v.y*m.m11+v.z*m.m12, v.x*m.m20+v.y*m.m21+v.z*m.m22); 
}

vector __operator__mul__(vector v, mat3 m) 
{
 return vector(v[0]*m.m00+v[1]*m.m01+v[2]*m.m02, v[0]*m.m10+v[1]*m.m11+v[2]*m.m12, v[0]*m.m20+v[1]*m.m21+v[2]*m.m22); 
}

mat3 rotationMatrixXYZ(vec3 v) {
    return rotationMatrix3(vec3(1.0,0.0,0.0), v.x)*
    rotationMatrix3(vec3(0.0,1.0,0.0), v.y)*
    rotationMatrix3(vec3(0.0,0.0,1.0), v.z);
}

mat3 rotationMatrixXYZ(vector v) {
    return rotationMatrix3(vector(1.0,0.0,0.0), v[0])*
    rotationMatrix3(vector(0.0,1.0,0.0), v[1])*
    rotationMatrix3(vector(0.0,0.0,1.0), v[2]);
}

mat3 euler_rotation(vector rot)
{
    vector v1=vector(-rot[0],-rot[1],-rot[2]);
    vector v2=radians(v1);
    vector rot_rad = v2;

    float cosx = cos(rot_rad[0]);
    float sinx = sin(rot_rad[0]);
    mat3 x = mat3(1.,            0.,              0.,        
                      0.,            cosx,           -sinx,   
                      0.,            sinx,          cosx           
                      );

    float cosy = cos(rot_rad[1]);
    float siny = sin(rot_rad[1]);
    mat3 y = mat3(cosy,         0.,              siny,           
                      0.,            1.,              0.,            
                      -siny,        0.,              cosy
                 );

    float cosz = cos(rot_rad[2]);
    float sinz = sin(rot_rad[2]);
    mat3 z = mat3(cosz,         -sinz,          0.,              
                      sinz,         cosz,           0.,        
                      0.,            0.,              1.
                );

    mat3 xform ;
    xform.m00=1.;
    xform.m01=0.;
    xform.m02=0.;
    xform.m10=0.;
    xform.m11=1.;
    xform.m12=0.;
    xform.m20=0.;
    xform.m21=0.;
    xform.m22=1.;
    xform = xform*x;
    xform = xform*y;
    xform = xform*z;

    return xform;
}

mat3 euler_rotation(vec3 rot)
{
    vector v1=vector(-rot.x,-rot.y,-rot.z);
    vector v2=radians(v1);
    vec3 rot_rad = vec3(v2[0],v2[1],v2[2]);

    float cosx = cos(rot_rad.x);
    float sinx = sin(rot_rad.x);
    mat3 x = mat3(1.,            0.,              0.,        
                      0.,            cosx,           -sinx,   
                      0.,            sinx,          cosx           
                      );

    float cosy = cos(rot_rad.y);
    float siny = sin(rot_rad.y);
    mat3 y = mat3(cosy,         0.,              siny,           
                      0.,            1.,              0.,            
                      -siny,        0.,              cosy
                 );

    float cosz = cos(rot_rad.z);
    float sinz = sin(rot_rad.z);
    mat3 z = mat3(cosz,         -sinz,          0.,              
                      sinz,         cosz,           0.,        
                      0.,            0.,              1.
                );

    mat3 xform ;
    xform.m00=1.;
    xform.m01=0.;
    xform.m02=0.;
    xform.m10=0.;
    xform.m11=1.;
    xform.m12=0.;
    xform.m20=0.;
    xform.m21=0.;
    xform.m22=1.;
    xform = xform*x;
    xform = xform*y;
    xform = xform*z;

    return xform;
}

#define UV_MODE_LINEAR 0
#define ADD_COLOR_PARAMS int ColorIterations = 16, \
int UMode = UV_MODE_LINEAR, \
float UScale = 1.
//int VMode = UV_MODE_LINEAR, \
//float VScale = 1

#define INIT_ORBIT_TRAP float colorValue = 10000.0
#define APPLY_ORBIT_TRAP   c.u = colorValue * UScale


shader OslGeometry(
// mandelbulb params
    int Iterations = 10,
    float Bailout = 10,	
    float Power = 9.0,
	float betaAngleOffset = 0.0,
	float alphaAngleOffset = 0.0,
	float juliax=0.,
	float juliay=0.,
	float juliaz=0.,
	float p0Scalex=1.0,
	float p0Scaley=1.0,
	float p0Scalez=1.0,
	int startBulb = 0,
	int stopBulb = 250,
// mandeltorusZ params
	int mode=1,
    float power1 = 9.0,
    float power2 = 9.0,
	float DEOffset=1.,
	float DEOffset2=2.,
	int startTorus = 0,
	int stopTorus = 250,
	
	ADD_COLOR_PARAMS,	
    output _sdf c = _SDFDEF)
{
    vec3 z = vec3(P[0],P[1],P[2]);
    vec3 p0Scale=vec3(p0Scalex,p0Scaley,p0Scalez);
    vec3 Julia=vec3(juliax,juliay,juliaz);
    
    float r = length(z);
    float dr = 1.0;
    vec3 p0=z*p0Scale;
  
  
  vec3 mandelbulb(vec3 z, output float r, output float dr)
  {
            float th0 = asin(z.z / r) + betaAngleOffset;
            float ph0 = atan2(z.y, z.x) + alphaAngleOffset;
            float rp = pow(r, Power - 1.0);
            float th = th0 * Power;
            float ph = ph0 * Power;
            float cth = cos(th);
            dr = rp * dr * Power + 1.0;
            rp *= r;
            z.x = cth * cos(ph) * rp;
            z.y = cth * sin(ph) * rp;
            z.z = sin(th) * rp;
            return z;
  }  
  
  vec3 mandeltorus(vec3 z, output float r, output float dr)
  {
          float rh = sqrt(z.x * z.x + z.y * z.y);
        float phi = atan2(z.y, z.x);
        float phipow = phi * power1;
        float theta = atan2(rh, z.z);
        float px = z.x - cos(phi) * 1.5;
        float py = z.y - sin(phi) * 1.5;
        float rhrad = sqrt(px * px + py * py + z.z * z.z);
        float rh1 = pow(rhrad, power2);
        float rh2 = pow(rhrad, power1);
    
        if (mode==1) // mode 1
        {
            float thetapow = theta * power2; // mode1
            float sintheta = sin(thetapow) * rh2; // mode1

            z.x = sintheta * cos(phipow);
            z.y = sintheta * sin(phipow);
            z.z = cos(thetapow) * rh1;      // mode 1
        }
        else // mode 2
        {
            float tangle = atan2(sqrt(px * px + py * py), z.z) * power2; // mode2
            float sintheta = (1.5 + cos(tangle)) * rh2; // mode2
            z.x = sintheta * cos(phipow);
            z.y = sintheta * sin(phipow);
            z.z = sin(tangle) * rh1; // mode 2
        }
// DE calc
        float temp=rh2*(power1-DEOffset2);
        dr=temp*dr + DEOffset;
        return z;
  }
  
    INIT_ORBIT_TRAP;
    for (int i = 0; i < Iterations ; i++)
    {

//mandelbulb 
        if ( i >= startBulb && i < stopBulb)
        {
            z=mandeltorus(z,r,dr);  
            z = z + p0 + Julia;                       	
            r = length(z);
            if (r > Bailout) break;
            if (i < ColorIterations) colorValue = min(colorValue, r);
        }	
        
//mandeltorus 
        if ( i >= startTorus && i < stopTorus)
        {
            z=mandelbulb(z,r,dr);
            z = z + p0 + Julia;
            r = length(z);       
            if (r>Bailout) break;
            if (i < ColorIterations) colorValue = min(colorValue, r);
        }
    }
    
    c.dist = 0.5 * log(r) * r / dr;
    APPLY_ORBIT_TRAP;
}